alias memory_page S0;
alias disk_block S1;
alias pid_init S2;
alias counter S3;
alias pcb S4;
alias pid_exec S5;
alias ptbr S6;

//loading exception handler, timer & INT[1-7] interrupts
memory_page = 7; 
disk_block = 1;
while (memory_page <= 23) do
    load(memory_page,disk_block);
    memory_page = memory_page + 1; 
    disk_block = disk_block + 1;
    load(memory_page,disk_block);
    memory_page = memory_page + 1; 
    disk_block = disk_block + 1;
endwhile;

//loading init program
memory_page = 25;
disk_block = 21;
while (memory_page <= 27) do 
    load(memory_page,disk_block);
    memory_page = memory_page + 1;
    disk_block = disk_block + 1;
endwhile;

//setting up init page table 
pid_init = 0; 
PTBR = PAGE_TABLE + 8*pid_init;
PTLR = 4;
BP = (PTLR-1)*512;
SP = BP;
memory_page = 25;
counter = 0;
while (counter < PTLR) do
    [PTBR + 2*counter] = memory_page;
    [PTBR + 2*counter + 1] = "01";
    memory_page = memory_page + 1;
    counter = counter + 1;
endwhile;

//setting up init pcb
pcb = READY_LIST + 32*pid_init;
[pcb + 0] = pid_init; //pid 
[pcb + 1] = 2; //state -- running
[pcb + 2] = BP;//BP
[pcb + 3] = SP; //SP
//IP can't be set 
[pcb + 5] = PTBR;
[pcb + 6] = PTLR;


//loading other executable
memory_page = 29;
disk_block = 25;
load(memory_page,disk_block);


//setting up executable page table
pid_exec = 1;
ptbr = PAGE_TABLE + 8*pid_exec;
counter = 0;
[ptbr + 2*counter] = 29;
[ptbr + 2*counter + 1] = "01";
counter = 3;
[ptbr + 2*counter] = 32;
[ptbr + 2*counter + 1] = "01";


//setting up executable pcb 
pcb = READY_LIST + 32*pid_exec;
[pcb + 0] = pid_exec;
[pcb + 1] = 1;
[pcb + 2] = 1536;
[pcb + 3] = 1536;
[pcb + 5] = ptbr;
[pcb + 6] = PTLR;


[28*512] = 0; //top of stack, 4th page 
ireturn;