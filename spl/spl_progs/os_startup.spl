alias memory_page S0;
alias disk_block S1;
alias pid_init S2;
alias counter S3;
alias pcb S4;

//initialising system wide open file table
counter = 0;
while(counter < 64) do 
    [FILE_TABLE + 2*counter] = -1; //setting pointer to fat as -1
    counter = counter + 1;
endwhile;

//loading FAT,disk_free_list
load(5,19);
load(6,20);

//loading exception handler, timer & INT[1-7] interrupts
memory_page = 7; 
disk_block = 1;
while (memory_page <= 23) do
    load(memory_page,disk_block);
    memory_page = memory_page + 1; 
    disk_block = disk_block + 1;
    load(memory_page,disk_block);
    memory_page = memory_page + 1; 
    disk_block = disk_block + 1;
endwhile;

//loading init program
memory_page = 25;
disk_block = 21;
while (memory_page <= 27) do 
    load(memory_page,disk_block);
    memory_page = memory_page + 1;
    disk_block = disk_block + 1;
endwhile;

//setting up init page table 
pid_init = 0; 
PTBR = PAGE_TABLE + 8*pid_init;
PTLR = 4;
BP = (PTLR-1)*512;
SP = BP;
memory_page = 25;
counter = 0;
while (counter < PTLR) do
    [PTBR + 2*counter] = memory_page;
    [PTBR + 2*counter + 1] = "01";
    memory_page = memory_page + 1;
    counter = counter + 1;
endwhile;

//setting up init pcb
pcb = READY_LIST + 32*pid_init;
[pcb + 0] = pid_init; //pid 
[pcb + 1] = 2; //state -- running
[pcb + 2] = BP;//BP
[pcb + 3] = SP; //SP
//IP can't be set 
[pcb + 5] = PTBR;
[pcb + 6] = PTLR;
//setting up init per process open file table in init's pcb
counter = 0;
while(counter < 8) do 
    [pcb + 15 + 2*counter] = -1;
    counter = counter + 1;
endwhile;

[28*512] = 0; //top of stack, 4th page
ireturn;